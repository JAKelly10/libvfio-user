diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c
index 580099afeaff..1870f7401265 100644
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@ -2172,10 +2172,17 @@ static int vfio_register_iommu_notifier(struct vfio_group *group,
 
 	container = group->container;
 	driver = container->iommu_driver;
-	if (likely(driver && driver->ops->register_notifier))
+	if (likely(driver && driver->ops->register_notifier)) {
 		ret = driver->ops->register_notifier(container->iommu_data,
 						     events, nb);
-	else
+		if (unlikely(!ret) && driver->ops->retro_notify) {
+			ret = driver->ops->retro_notify(container->iommu_data);
+			if (unlikely((ret & NOTIFY_BAD) == NOTIFY_BAD))
+				ret = -ENOTTY;
+			else
+				ret = 0;
+		}
+	} else
 		ret = -ENOTTY;
 
 	vfio_group_try_dissolve_container(group);
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 5e556ac9102a..d8496ad26e63 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -1293,6 +1293,30 @@ static bool vfio_iommu_iova_dma_valid(struct vfio_iommu *iommu,
 	return list_empty(iova);
 }
 
+static int vfio_dma_map_trigger_notifiers(struct vfio_iommu * const iommu,
+		struct vfio_dma const * const dma)
+
+{
+	struct vfio_iommu_type1_dma_map nb_map = {0};
+
+	BUG_ON(!iommu);
+	BUG_ON(!dma);
+
+	nb_map.flags = dma->prot;
+
+	if ((dma->prot & IOMMU_READ) == IOMMU_READ)
+		nb_map.flags |= VFIO_DMA_MAP_FLAG_READ;
+	if ((dma->prot & IOMMU_WRITE) == IOMMU_WRITE)
+		nb_map.flags |= VFIO_DMA_MAP_FLAG_WRITE;
+	nb_map.vaddr = dma->vaddr;
+	nb_map.iova = dma->iova;
+	nb_map.size = dma->size;
+
+	return blocking_notifier_call_chain(&iommu->notifier,
+				    VFIO_IOMMU_NOTIFY_DMA_MAP,
+				    &nb_map);
+}
+
 static int vfio_dma_do_map(struct vfio_iommu *iommu,
 			   struct vfio_iommu_type1_dma_map *map)
 {
@@ -1391,9 +1415,10 @@ static int vfio_dma_do_map(struct vfio_iommu *iommu,
 	vfio_link_dma(iommu, dma);
 
 	/* Don't pin and map if container doesn't contain IOMMU capable domain*/
-	if (!IS_IOMMU_CAP_DOMAIN_IN_CONTAINER(iommu))
+	if (!IS_IOMMU_CAP_DOMAIN_IN_CONTAINER(iommu)) {
 		dma->size = size;
-	else
+		ret = 0;
+	} else
 		ret = vfio_pin_map_dma(iommu, dma, size);
 
 	if (!ret && iommu->dirty_page_tracking) {
@@ -1404,6 +1429,17 @@ static int vfio_dma_do_map(struct vfio_iommu *iommu,
 
 out_unlock:
 	mutex_unlock(&iommu->lock);
+	/* FIXME is the following safe without having acquired the mutex? */
+	if (!IS_IOMMU_CAP_DOMAIN_IN_CONTAINER(iommu) && !ret) {
+		ret = vfio_dma_map_trigger_notifiers(iommu, dma);
+		/* FIXME proceed or clean up and fail? */
+		if ((ret & NOTIFY_BAD) == NOTIFY_BAD) {
+			pr_debug("failed to trigger notifier(s): %d\n", ret);
+			ret = -EINVAL;
+		} else
+			ret = 0;
+	}
+
 	return ret;
 }
 
@@ -2773,7 +2809,7 @@ static int vfio_iommu_type1_register_notifier(void *iommu_data,
 	struct vfio_iommu *iommu = iommu_data;
 
 	/* clear known events */
-	*events &= ~VFIO_IOMMU_NOTIFY_DMA_UNMAP;
+	*events &= ~(VFIO_IOMMU_NOTIFY_DMA_MAP | VFIO_IOMMU_NOTIFY_DMA_UNMAP);
 
 	/* refuse to register if still events remaining */
 	if (*events)
@@ -2782,6 +2818,25 @@ static int vfio_iommu_type1_register_notifier(void *iommu_data,
 	return blocking_notifier_chain_register(&iommu->notifier, nb);
 }
 
+static int vfio_iommu_type1_retro_notify(void *iommu_data)
+{
+	int err = NOTIFY_OK;
+	struct vfio_iommu *iommu;
+	struct vfio_dma *pos, *n;
+
+	BUG_ON(!iommu_data);
+
+	iommu = (struct vfio_iommu*)iommu_data;
+
+	rbtree_postorder_for_each_entry_safe(pos, n, &iommu->dma_list, node) {
+		err = vfio_dma_map_trigger_notifiers(iommu, pos);
+		if ((err & NOTIFY_BAD) == NOTIFY_BAD)
+			break;
+	}
+
+	return err;
+}
+
 static int vfio_iommu_type1_unregister_notifier(void *iommu_data,
 						struct notifier_block *nb)
 {
@@ -2885,6 +2940,7 @@ static const struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1 = {
 	.unpin_pages		= vfio_iommu_type1_unpin_pages,
 	.register_notifier	= vfio_iommu_type1_register_notifier,
 	.unregister_notifier	= vfio_iommu_type1_unregister_notifier,
+	.retro_notify	= vfio_iommu_type1_retro_notify,
 	.dma_rw			= vfio_iommu_type1_dma_rw,
 };
 
diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 38d3c6a8dc7e..afbba711c2a5 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -88,6 +88,7 @@ struct vfio_iommu_driver_ops {
 					     struct notifier_block *nb);
 	int		(*unregister_notifier)(void *iommu_data,
 					       struct notifier_block *nb);
+	int		(*retro_notify)(void *iommu_data);
 	int		(*dma_rw)(void *iommu_data, dma_addr_t user_iova,
 				  void *data, size_t count, bool write);
 };
@@ -134,6 +135,7 @@ enum vfio_notify_type {
 
 /* events for VFIO_IOMMU_NOTIFY */
 #define VFIO_IOMMU_NOTIFY_DMA_UNMAP	BIT(0)
+#define VFIO_IOMMU_NOTIFY_DMA_MAP	BIT(1)
 
 /* events for VFIO_GROUP_NOTIFY */
 #define VFIO_GROUP_NOTIFY_SET_KVM	BIT(0)
